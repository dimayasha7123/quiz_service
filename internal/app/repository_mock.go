package app

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i gitlab.ozon.dev/dimayasha7123/homework-2-dimayasha-7123/internal/app.Repository -o ./repository_mock.go -n RepositoryMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"gitlab.ozon.dev/dimayasha7123/homework-2-dimayasha-7123/internal/models"
)

// RepositoryMock implements Repository
type RepositoryMock struct {
	t minimock.Tester

	funcAddAllPartyQuestion          func(ctx context.Context, qa1 []models.Question, i1 int64) (err error)
	inspectFuncAddAllPartyQuestion   func(ctx context.Context, qa1 []models.Question, i1 int64)
	afterAddAllPartyQuestionCounter  uint64
	beforeAddAllPartyQuestionCounter uint64
	AddAllPartyQuestionMock          mRepositoryMockAddAllPartyQuestion

	funcAddParty          func(ctx context.Context, p1 models.Party) (i1 int64, err error)
	inspectFuncAddParty   func(ctx context.Context, p1 models.Party)
	afterAddPartyCounter  uint64
	beforeAddPartyCounter uint64
	AddPartyMock          mRepositoryMockAddParty

	funcAddQuestionsIfNot          func(ctx context.Context, qap1 *[]models.Question, i1 int64) (i2 int32, err error)
	inspectFuncAddQuestionsIfNot   func(ctx context.Context, qap1 *[]models.Question, i1 int64)
	afterAddQuestionsIfNotCounter  uint64
	beforeAddQuestionsIfNotCounter uint64
	AddQuestionsIfNotMock          mRepositoryMockAddQuestionsIfNot

	funcAddUser          func(ctx context.Context, s1 string) (i1 int64, err error)
	inspectFuncAddUser   func(ctx context.Context, s1 string)
	afterAddUserCounter  uint64
	beforeAddUserCounter uint64
	AddUserMock          mRepositoryMockAddUser

	funcCheckPartyCompleted          func(ctx context.Context, partyID int64) (b1 bool, err error)
	inspectFuncCheckPartyCompleted   func(ctx context.Context, partyID int64)
	afterCheckPartyCompletedCounter  uint64
	beforeCheckPartyCompletedCounter uint64
	CheckPartyCompletedMock          mRepositoryMockCheckPartyCompleted

	funcCompleteParty          func(ctx context.Context, partyID int64, points int32) (s1 models.SingleTop, err error)
	inspectFuncCompleteParty   func(ctx context.Context, partyID int64, points int32)
	afterCompletePartyCounter  uint64
	beforeCompletePartyCounter uint64
	CompletePartyMock          mRepositoryMockCompleteParty

	funcGetQuiz          func(ctx context.Context, i1 int64) (q1 models.Quiz, err error)
	inspectFuncGetQuiz   func(ctx context.Context, i1 int64)
	afterGetQuizCounter  uint64
	beforeGetQuizCounter uint64
	GetQuizMock          mRepositoryMockGetQuiz

	funcGetQuizList          func(ctx context.Context) (qa1 []models.Quiz, err error)
	inspectFuncGetQuizList   func(ctx context.Context)
	afterGetQuizListCounter  uint64
	beforeGetQuizListCounter uint64
	GetQuizListMock          mRepositoryMockGetQuizList

	funcGetQuizTop          func(ctx context.Context, quizID int64) (g1 models.GlobalTop, err error)
	inspectFuncGetQuizTop   func(ctx context.Context, quizID int64)
	afterGetQuizTopCounter  uint64
	beforeGetQuizTopCounter uint64
	GetQuizTopMock          mRepositoryMockGetQuizTop

	funcGetRightAnswers          func(ctx context.Context, partyID int64) (iaa1 [][]int32, err error)
	inspectFuncGetRightAnswers   func(ctx context.Context, partyID int64)
	afterGetRightAnswersCounter  uint64
	beforeGetRightAnswersCounter uint64
	GetRightAnswersMock          mRepositoryMockGetRightAnswers

	funcGetUserQuizTop          func(ctx context.Context, quizID int64, userID int64) (s1 models.SingleTop, err error)
	inspectFuncGetUserQuizTop   func(ctx context.Context, quizID int64, userID int64)
	afterGetUserQuizTopCounter  uint64
	beforeGetUserQuizTopCounter uint64
	GetUserQuizTopMock          mRepositoryMockGetUserQuizTop
}

// NewRepositoryMock returns a mock for Repository
func NewRepositoryMock(t minimock.Tester) *RepositoryMock {
	m := &RepositoryMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddAllPartyQuestionMock = mRepositoryMockAddAllPartyQuestion{mock: m}
	m.AddAllPartyQuestionMock.callArgs = []*RepositoryMockAddAllPartyQuestionParams{}

	m.AddPartyMock = mRepositoryMockAddParty{mock: m}
	m.AddPartyMock.callArgs = []*RepositoryMockAddPartyParams{}

	m.AddQuestionsIfNotMock = mRepositoryMockAddQuestionsIfNot{mock: m}
	m.AddQuestionsIfNotMock.callArgs = []*RepositoryMockAddQuestionsIfNotParams{}

	m.AddUserMock = mRepositoryMockAddUser{mock: m}
	m.AddUserMock.callArgs = []*RepositoryMockAddUserParams{}

	m.CheckPartyCompletedMock = mRepositoryMockCheckPartyCompleted{mock: m}
	m.CheckPartyCompletedMock.callArgs = []*RepositoryMockCheckPartyCompletedParams{}

	m.CompletePartyMock = mRepositoryMockCompleteParty{mock: m}
	m.CompletePartyMock.callArgs = []*RepositoryMockCompletePartyParams{}

	m.GetQuizMock = mRepositoryMockGetQuiz{mock: m}
	m.GetQuizMock.callArgs = []*RepositoryMockGetQuizParams{}

	m.GetQuizListMock = mRepositoryMockGetQuizList{mock: m}
	m.GetQuizListMock.callArgs = []*RepositoryMockGetQuizListParams{}

	m.GetQuizTopMock = mRepositoryMockGetQuizTop{mock: m}
	m.GetQuizTopMock.callArgs = []*RepositoryMockGetQuizTopParams{}

	m.GetRightAnswersMock = mRepositoryMockGetRightAnswers{mock: m}
	m.GetRightAnswersMock.callArgs = []*RepositoryMockGetRightAnswersParams{}

	m.GetUserQuizTopMock = mRepositoryMockGetUserQuizTop{mock: m}
	m.GetUserQuizTopMock.callArgs = []*RepositoryMockGetUserQuizTopParams{}

	return m
}

type mRepositoryMockAddAllPartyQuestion struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockAddAllPartyQuestionExpectation
	expectations       []*RepositoryMockAddAllPartyQuestionExpectation

	callArgs []*RepositoryMockAddAllPartyQuestionParams
	mutex    sync.RWMutex
}

// RepositoryMockAddAllPartyQuestionExpectation specifies expectation struct of the Repository.AddAllPartyQuestion
type RepositoryMockAddAllPartyQuestionExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockAddAllPartyQuestionParams
	results *RepositoryMockAddAllPartyQuestionResults
	Counter uint64
}

// RepositoryMockAddAllPartyQuestionParams contains parameters of the Repository.AddAllPartyQuestion
type RepositoryMockAddAllPartyQuestionParams struct {
	ctx context.Context
	qa1 []models.Question
	i1  int64
}

// RepositoryMockAddAllPartyQuestionResults contains results of the Repository.AddAllPartyQuestion
type RepositoryMockAddAllPartyQuestionResults struct {
	err error
}

// Expect sets up expected params for Repository.AddAllPartyQuestion
func (mmAddAllPartyQuestion *mRepositoryMockAddAllPartyQuestion) Expect(ctx context.Context, qa1 []models.Question, i1 int64) *mRepositoryMockAddAllPartyQuestion {
	if mmAddAllPartyQuestion.mock.funcAddAllPartyQuestion != nil {
		mmAddAllPartyQuestion.mock.t.Fatalf("RepositoryMock.AddAllPartyQuestion mock is already set by Set")
	}

	if mmAddAllPartyQuestion.defaultExpectation == nil {
		mmAddAllPartyQuestion.defaultExpectation = &RepositoryMockAddAllPartyQuestionExpectation{}
	}

	mmAddAllPartyQuestion.defaultExpectation.params = &RepositoryMockAddAllPartyQuestionParams{ctx, qa1, i1}
	for _, e := range mmAddAllPartyQuestion.expectations {
		if minimock.Equal(e.params, mmAddAllPartyQuestion.defaultExpectation.params) {
			mmAddAllPartyQuestion.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddAllPartyQuestion.defaultExpectation.params)
		}
	}

	return mmAddAllPartyQuestion
}

// Inspect accepts an inspector function that has same arguments as the Repository.AddAllPartyQuestion
func (mmAddAllPartyQuestion *mRepositoryMockAddAllPartyQuestion) Inspect(f func(ctx context.Context, qa1 []models.Question, i1 int64)) *mRepositoryMockAddAllPartyQuestion {
	if mmAddAllPartyQuestion.mock.inspectFuncAddAllPartyQuestion != nil {
		mmAddAllPartyQuestion.mock.t.Fatalf("Inspect function is already set for RepositoryMock.AddAllPartyQuestion")
	}

	mmAddAllPartyQuestion.mock.inspectFuncAddAllPartyQuestion = f

	return mmAddAllPartyQuestion
}

// Return sets up results that will be returned by Repository.AddAllPartyQuestion
func (mmAddAllPartyQuestion *mRepositoryMockAddAllPartyQuestion) Return(err error) *RepositoryMock {
	if mmAddAllPartyQuestion.mock.funcAddAllPartyQuestion != nil {
		mmAddAllPartyQuestion.mock.t.Fatalf("RepositoryMock.AddAllPartyQuestion mock is already set by Set")
	}

	if mmAddAllPartyQuestion.defaultExpectation == nil {
		mmAddAllPartyQuestion.defaultExpectation = &RepositoryMockAddAllPartyQuestionExpectation{mock: mmAddAllPartyQuestion.mock}
	}
	mmAddAllPartyQuestion.defaultExpectation.results = &RepositoryMockAddAllPartyQuestionResults{err}
	return mmAddAllPartyQuestion.mock
}

//Set uses given function f to mock the Repository.AddAllPartyQuestion method
func (mmAddAllPartyQuestion *mRepositoryMockAddAllPartyQuestion) Set(f func(ctx context.Context, qa1 []models.Question, i1 int64) (err error)) *RepositoryMock {
	if mmAddAllPartyQuestion.defaultExpectation != nil {
		mmAddAllPartyQuestion.mock.t.Fatalf("Default expectation is already set for the Repository.AddAllPartyQuestion method")
	}

	if len(mmAddAllPartyQuestion.expectations) > 0 {
		mmAddAllPartyQuestion.mock.t.Fatalf("Some expectations are already set for the Repository.AddAllPartyQuestion method")
	}

	mmAddAllPartyQuestion.mock.funcAddAllPartyQuestion = f
	return mmAddAllPartyQuestion.mock
}

// When sets expectation for the Repository.AddAllPartyQuestion which will trigger the result defined by the following
// Then helper
func (mmAddAllPartyQuestion *mRepositoryMockAddAllPartyQuestion) When(ctx context.Context, qa1 []models.Question, i1 int64) *RepositoryMockAddAllPartyQuestionExpectation {
	if mmAddAllPartyQuestion.mock.funcAddAllPartyQuestion != nil {
		mmAddAllPartyQuestion.mock.t.Fatalf("RepositoryMock.AddAllPartyQuestion mock is already set by Set")
	}

	expectation := &RepositoryMockAddAllPartyQuestionExpectation{
		mock:   mmAddAllPartyQuestion.mock,
		params: &RepositoryMockAddAllPartyQuestionParams{ctx, qa1, i1},
	}
	mmAddAllPartyQuestion.expectations = append(mmAddAllPartyQuestion.expectations, expectation)
	return expectation
}

// Then sets up Repository.AddAllPartyQuestion return parameters for the expectation previously defined by the When method
func (e *RepositoryMockAddAllPartyQuestionExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockAddAllPartyQuestionResults{err}
	return e.mock
}

// AddAllPartyQuestion implements Repository
func (mmAddAllPartyQuestion *RepositoryMock) AddAllPartyQuestion(ctx context.Context, qa1 []models.Question, i1 int64) (err error) {
	mm_atomic.AddUint64(&mmAddAllPartyQuestion.beforeAddAllPartyQuestionCounter, 1)
	defer mm_atomic.AddUint64(&mmAddAllPartyQuestion.afterAddAllPartyQuestionCounter, 1)

	if mmAddAllPartyQuestion.inspectFuncAddAllPartyQuestion != nil {
		mmAddAllPartyQuestion.inspectFuncAddAllPartyQuestion(ctx, qa1, i1)
	}

	mm_params := &RepositoryMockAddAllPartyQuestionParams{ctx, qa1, i1}

	// Record call args
	mmAddAllPartyQuestion.AddAllPartyQuestionMock.mutex.Lock()
	mmAddAllPartyQuestion.AddAllPartyQuestionMock.callArgs = append(mmAddAllPartyQuestion.AddAllPartyQuestionMock.callArgs, mm_params)
	mmAddAllPartyQuestion.AddAllPartyQuestionMock.mutex.Unlock()

	for _, e := range mmAddAllPartyQuestion.AddAllPartyQuestionMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddAllPartyQuestion.AddAllPartyQuestionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddAllPartyQuestion.AddAllPartyQuestionMock.defaultExpectation.Counter, 1)
		mm_want := mmAddAllPartyQuestion.AddAllPartyQuestionMock.defaultExpectation.params
		mm_got := RepositoryMockAddAllPartyQuestionParams{ctx, qa1, i1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddAllPartyQuestion.t.Errorf("RepositoryMock.AddAllPartyQuestion got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddAllPartyQuestion.AddAllPartyQuestionMock.defaultExpectation.results
		if mm_results == nil {
			mmAddAllPartyQuestion.t.Fatal("No results are set for the RepositoryMock.AddAllPartyQuestion")
		}
		return (*mm_results).err
	}
	if mmAddAllPartyQuestion.funcAddAllPartyQuestion != nil {
		return mmAddAllPartyQuestion.funcAddAllPartyQuestion(ctx, qa1, i1)
	}
	mmAddAllPartyQuestion.t.Fatalf("Unexpected call to RepositoryMock.AddAllPartyQuestion. %v %v %v", ctx, qa1, i1)
	return
}

// AddAllPartyQuestionAfterCounter returns a count of finished RepositoryMock.AddAllPartyQuestion invocations
func (mmAddAllPartyQuestion *RepositoryMock) AddAllPartyQuestionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddAllPartyQuestion.afterAddAllPartyQuestionCounter)
}

// AddAllPartyQuestionBeforeCounter returns a count of RepositoryMock.AddAllPartyQuestion invocations
func (mmAddAllPartyQuestion *RepositoryMock) AddAllPartyQuestionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddAllPartyQuestion.beforeAddAllPartyQuestionCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.AddAllPartyQuestion.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddAllPartyQuestion *mRepositoryMockAddAllPartyQuestion) Calls() []*RepositoryMockAddAllPartyQuestionParams {
	mmAddAllPartyQuestion.mutex.RLock()

	argCopy := make([]*RepositoryMockAddAllPartyQuestionParams, len(mmAddAllPartyQuestion.callArgs))
	copy(argCopy, mmAddAllPartyQuestion.callArgs)

	mmAddAllPartyQuestion.mutex.RUnlock()

	return argCopy
}

// MinimockAddAllPartyQuestionDone returns true if the count of the AddAllPartyQuestion invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockAddAllPartyQuestionDone() bool {
	for _, e := range m.AddAllPartyQuestionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddAllPartyQuestionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddAllPartyQuestionCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddAllPartyQuestion != nil && mm_atomic.LoadUint64(&m.afterAddAllPartyQuestionCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddAllPartyQuestionInspect logs each unmet expectation
func (m *RepositoryMock) MinimockAddAllPartyQuestionInspect() {
	for _, e := range m.AddAllPartyQuestionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.AddAllPartyQuestion with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddAllPartyQuestionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddAllPartyQuestionCounter) < 1 {
		if m.AddAllPartyQuestionMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.AddAllPartyQuestion")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.AddAllPartyQuestion with params: %#v", *m.AddAllPartyQuestionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddAllPartyQuestion != nil && mm_atomic.LoadUint64(&m.afterAddAllPartyQuestionCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.AddAllPartyQuestion")
	}
}

type mRepositoryMockAddParty struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockAddPartyExpectation
	expectations       []*RepositoryMockAddPartyExpectation

	callArgs []*RepositoryMockAddPartyParams
	mutex    sync.RWMutex
}

// RepositoryMockAddPartyExpectation specifies expectation struct of the Repository.AddParty
type RepositoryMockAddPartyExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockAddPartyParams
	results *RepositoryMockAddPartyResults
	Counter uint64
}

// RepositoryMockAddPartyParams contains parameters of the Repository.AddParty
type RepositoryMockAddPartyParams struct {
	ctx context.Context
	p1  models.Party
}

// RepositoryMockAddPartyResults contains results of the Repository.AddParty
type RepositoryMockAddPartyResults struct {
	i1  int64
	err error
}

// Expect sets up expected params for Repository.AddParty
func (mmAddParty *mRepositoryMockAddParty) Expect(ctx context.Context, p1 models.Party) *mRepositoryMockAddParty {
	if mmAddParty.mock.funcAddParty != nil {
		mmAddParty.mock.t.Fatalf("RepositoryMock.AddParty mock is already set by Set")
	}

	if mmAddParty.defaultExpectation == nil {
		mmAddParty.defaultExpectation = &RepositoryMockAddPartyExpectation{}
	}

	mmAddParty.defaultExpectation.params = &RepositoryMockAddPartyParams{ctx, p1}
	for _, e := range mmAddParty.expectations {
		if minimock.Equal(e.params, mmAddParty.defaultExpectation.params) {
			mmAddParty.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddParty.defaultExpectation.params)
		}
	}

	return mmAddParty
}

// Inspect accepts an inspector function that has same arguments as the Repository.AddParty
func (mmAddParty *mRepositoryMockAddParty) Inspect(f func(ctx context.Context, p1 models.Party)) *mRepositoryMockAddParty {
	if mmAddParty.mock.inspectFuncAddParty != nil {
		mmAddParty.mock.t.Fatalf("Inspect function is already set for RepositoryMock.AddParty")
	}

	mmAddParty.mock.inspectFuncAddParty = f

	return mmAddParty
}

// Return sets up results that will be returned by Repository.AddParty
func (mmAddParty *mRepositoryMockAddParty) Return(i1 int64, err error) *RepositoryMock {
	if mmAddParty.mock.funcAddParty != nil {
		mmAddParty.mock.t.Fatalf("RepositoryMock.AddParty mock is already set by Set")
	}

	if mmAddParty.defaultExpectation == nil {
		mmAddParty.defaultExpectation = &RepositoryMockAddPartyExpectation{mock: mmAddParty.mock}
	}
	mmAddParty.defaultExpectation.results = &RepositoryMockAddPartyResults{i1, err}
	return mmAddParty.mock
}

//Set uses given function f to mock the Repository.AddParty method
func (mmAddParty *mRepositoryMockAddParty) Set(f func(ctx context.Context, p1 models.Party) (i1 int64, err error)) *RepositoryMock {
	if mmAddParty.defaultExpectation != nil {
		mmAddParty.mock.t.Fatalf("Default expectation is already set for the Repository.AddParty method")
	}

	if len(mmAddParty.expectations) > 0 {
		mmAddParty.mock.t.Fatalf("Some expectations are already set for the Repository.AddParty method")
	}

	mmAddParty.mock.funcAddParty = f
	return mmAddParty.mock
}

// When sets expectation for the Repository.AddParty which will trigger the result defined by the following
// Then helper
func (mmAddParty *mRepositoryMockAddParty) When(ctx context.Context, p1 models.Party) *RepositoryMockAddPartyExpectation {
	if mmAddParty.mock.funcAddParty != nil {
		mmAddParty.mock.t.Fatalf("RepositoryMock.AddParty mock is already set by Set")
	}

	expectation := &RepositoryMockAddPartyExpectation{
		mock:   mmAddParty.mock,
		params: &RepositoryMockAddPartyParams{ctx, p1},
	}
	mmAddParty.expectations = append(mmAddParty.expectations, expectation)
	return expectation
}

// Then sets up Repository.AddParty return parameters for the expectation previously defined by the When method
func (e *RepositoryMockAddPartyExpectation) Then(i1 int64, err error) *RepositoryMock {
	e.results = &RepositoryMockAddPartyResults{i1, err}
	return e.mock
}

// AddParty implements Repository
func (mmAddParty *RepositoryMock) AddParty(ctx context.Context, p1 models.Party) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmAddParty.beforeAddPartyCounter, 1)
	defer mm_atomic.AddUint64(&mmAddParty.afterAddPartyCounter, 1)

	if mmAddParty.inspectFuncAddParty != nil {
		mmAddParty.inspectFuncAddParty(ctx, p1)
	}

	mm_params := &RepositoryMockAddPartyParams{ctx, p1}

	// Record call args
	mmAddParty.AddPartyMock.mutex.Lock()
	mmAddParty.AddPartyMock.callArgs = append(mmAddParty.AddPartyMock.callArgs, mm_params)
	mmAddParty.AddPartyMock.mutex.Unlock()

	for _, e := range mmAddParty.AddPartyMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmAddParty.AddPartyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddParty.AddPartyMock.defaultExpectation.Counter, 1)
		mm_want := mmAddParty.AddPartyMock.defaultExpectation.params
		mm_got := RepositoryMockAddPartyParams{ctx, p1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddParty.t.Errorf("RepositoryMock.AddParty got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddParty.AddPartyMock.defaultExpectation.results
		if mm_results == nil {
			mmAddParty.t.Fatal("No results are set for the RepositoryMock.AddParty")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmAddParty.funcAddParty != nil {
		return mmAddParty.funcAddParty(ctx, p1)
	}
	mmAddParty.t.Fatalf("Unexpected call to RepositoryMock.AddParty. %v %v", ctx, p1)
	return
}

// AddPartyAfterCounter returns a count of finished RepositoryMock.AddParty invocations
func (mmAddParty *RepositoryMock) AddPartyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddParty.afterAddPartyCounter)
}

// AddPartyBeforeCounter returns a count of RepositoryMock.AddParty invocations
func (mmAddParty *RepositoryMock) AddPartyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddParty.beforeAddPartyCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.AddParty.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddParty *mRepositoryMockAddParty) Calls() []*RepositoryMockAddPartyParams {
	mmAddParty.mutex.RLock()

	argCopy := make([]*RepositoryMockAddPartyParams, len(mmAddParty.callArgs))
	copy(argCopy, mmAddParty.callArgs)

	mmAddParty.mutex.RUnlock()

	return argCopy
}

// MinimockAddPartyDone returns true if the count of the AddParty invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockAddPartyDone() bool {
	for _, e := range m.AddPartyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddPartyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddPartyCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddParty != nil && mm_atomic.LoadUint64(&m.afterAddPartyCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddPartyInspect logs each unmet expectation
func (m *RepositoryMock) MinimockAddPartyInspect() {
	for _, e := range m.AddPartyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.AddParty with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddPartyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddPartyCounter) < 1 {
		if m.AddPartyMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.AddParty")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.AddParty with params: %#v", *m.AddPartyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddParty != nil && mm_atomic.LoadUint64(&m.afterAddPartyCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.AddParty")
	}
}

type mRepositoryMockAddQuestionsIfNot struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockAddQuestionsIfNotExpectation
	expectations       []*RepositoryMockAddQuestionsIfNotExpectation

	callArgs []*RepositoryMockAddQuestionsIfNotParams
	mutex    sync.RWMutex
}

// RepositoryMockAddQuestionsIfNotExpectation specifies expectation struct of the Repository.AddQuestionsIfNot
type RepositoryMockAddQuestionsIfNotExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockAddQuestionsIfNotParams
	results *RepositoryMockAddQuestionsIfNotResults
	Counter uint64
}

// RepositoryMockAddQuestionsIfNotParams contains parameters of the Repository.AddQuestionsIfNot
type RepositoryMockAddQuestionsIfNotParams struct {
	ctx  context.Context
	qap1 *[]models.Question
	i1   int64
}

// RepositoryMockAddQuestionsIfNotResults contains results of the Repository.AddQuestionsIfNot
type RepositoryMockAddQuestionsIfNotResults struct {
	i2  int32
	err error
}

// Expect sets up expected params for Repository.AddQuestionsIfNot
func (mmAddQuestionsIfNot *mRepositoryMockAddQuestionsIfNot) Expect(ctx context.Context, qap1 *[]models.Question, i1 int64) *mRepositoryMockAddQuestionsIfNot {
	if mmAddQuestionsIfNot.mock.funcAddQuestionsIfNot != nil {
		mmAddQuestionsIfNot.mock.t.Fatalf("RepositoryMock.AddQuestionsIfNot mock is already set by Set")
	}

	if mmAddQuestionsIfNot.defaultExpectation == nil {
		mmAddQuestionsIfNot.defaultExpectation = &RepositoryMockAddQuestionsIfNotExpectation{}
	}

	mmAddQuestionsIfNot.defaultExpectation.params = &RepositoryMockAddQuestionsIfNotParams{ctx, qap1, i1}
	for _, e := range mmAddQuestionsIfNot.expectations {
		if minimock.Equal(e.params, mmAddQuestionsIfNot.defaultExpectation.params) {
			mmAddQuestionsIfNot.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddQuestionsIfNot.defaultExpectation.params)
		}
	}

	return mmAddQuestionsIfNot
}

// Inspect accepts an inspector function that has same arguments as the Repository.AddQuestionsIfNot
func (mmAddQuestionsIfNot *mRepositoryMockAddQuestionsIfNot) Inspect(f func(ctx context.Context, qap1 *[]models.Question, i1 int64)) *mRepositoryMockAddQuestionsIfNot {
	if mmAddQuestionsIfNot.mock.inspectFuncAddQuestionsIfNot != nil {
		mmAddQuestionsIfNot.mock.t.Fatalf("Inspect function is already set for RepositoryMock.AddQuestionsIfNot")
	}

	mmAddQuestionsIfNot.mock.inspectFuncAddQuestionsIfNot = f

	return mmAddQuestionsIfNot
}

// Return sets up results that will be returned by Repository.AddQuestionsIfNot
func (mmAddQuestionsIfNot *mRepositoryMockAddQuestionsIfNot) Return(i2 int32, err error) *RepositoryMock {
	if mmAddQuestionsIfNot.mock.funcAddQuestionsIfNot != nil {
		mmAddQuestionsIfNot.mock.t.Fatalf("RepositoryMock.AddQuestionsIfNot mock is already set by Set")
	}

	if mmAddQuestionsIfNot.defaultExpectation == nil {
		mmAddQuestionsIfNot.defaultExpectation = &RepositoryMockAddQuestionsIfNotExpectation{mock: mmAddQuestionsIfNot.mock}
	}
	mmAddQuestionsIfNot.defaultExpectation.results = &RepositoryMockAddQuestionsIfNotResults{i2, err}
	return mmAddQuestionsIfNot.mock
}

//Set uses given function f to mock the Repository.AddQuestionsIfNot method
func (mmAddQuestionsIfNot *mRepositoryMockAddQuestionsIfNot) Set(f func(ctx context.Context, qap1 *[]models.Question, i1 int64) (i2 int32, err error)) *RepositoryMock {
	if mmAddQuestionsIfNot.defaultExpectation != nil {
		mmAddQuestionsIfNot.mock.t.Fatalf("Default expectation is already set for the Repository.AddQuestionsIfNot method")
	}

	if len(mmAddQuestionsIfNot.expectations) > 0 {
		mmAddQuestionsIfNot.mock.t.Fatalf("Some expectations are already set for the Repository.AddQuestionsIfNot method")
	}

	mmAddQuestionsIfNot.mock.funcAddQuestionsIfNot = f
	return mmAddQuestionsIfNot.mock
}

// When sets expectation for the Repository.AddQuestionsIfNot which will trigger the result defined by the following
// Then helper
func (mmAddQuestionsIfNot *mRepositoryMockAddQuestionsIfNot) When(ctx context.Context, qap1 *[]models.Question, i1 int64) *RepositoryMockAddQuestionsIfNotExpectation {
	if mmAddQuestionsIfNot.mock.funcAddQuestionsIfNot != nil {
		mmAddQuestionsIfNot.mock.t.Fatalf("RepositoryMock.AddQuestionsIfNot mock is already set by Set")
	}

	expectation := &RepositoryMockAddQuestionsIfNotExpectation{
		mock:   mmAddQuestionsIfNot.mock,
		params: &RepositoryMockAddQuestionsIfNotParams{ctx, qap1, i1},
	}
	mmAddQuestionsIfNot.expectations = append(mmAddQuestionsIfNot.expectations, expectation)
	return expectation
}

// Then sets up Repository.AddQuestionsIfNot return parameters for the expectation previously defined by the When method
func (e *RepositoryMockAddQuestionsIfNotExpectation) Then(i2 int32, err error) *RepositoryMock {
	e.results = &RepositoryMockAddQuestionsIfNotResults{i2, err}
	return e.mock
}

// AddQuestionsIfNot implements Repository
func (mmAddQuestionsIfNot *RepositoryMock) AddQuestionsIfNot(ctx context.Context, qap1 *[]models.Question, i1 int64) (i2 int32, err error) {
	mm_atomic.AddUint64(&mmAddQuestionsIfNot.beforeAddQuestionsIfNotCounter, 1)
	defer mm_atomic.AddUint64(&mmAddQuestionsIfNot.afterAddQuestionsIfNotCounter, 1)

	if mmAddQuestionsIfNot.inspectFuncAddQuestionsIfNot != nil {
		mmAddQuestionsIfNot.inspectFuncAddQuestionsIfNot(ctx, qap1, i1)
	}

	mm_params := &RepositoryMockAddQuestionsIfNotParams{ctx, qap1, i1}

	// Record call args
	mmAddQuestionsIfNot.AddQuestionsIfNotMock.mutex.Lock()
	mmAddQuestionsIfNot.AddQuestionsIfNotMock.callArgs = append(mmAddQuestionsIfNot.AddQuestionsIfNotMock.callArgs, mm_params)
	mmAddQuestionsIfNot.AddQuestionsIfNotMock.mutex.Unlock()

	for _, e := range mmAddQuestionsIfNot.AddQuestionsIfNotMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i2, e.results.err
		}
	}

	if mmAddQuestionsIfNot.AddQuestionsIfNotMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddQuestionsIfNot.AddQuestionsIfNotMock.defaultExpectation.Counter, 1)
		mm_want := mmAddQuestionsIfNot.AddQuestionsIfNotMock.defaultExpectation.params
		mm_got := RepositoryMockAddQuestionsIfNotParams{ctx, qap1, i1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddQuestionsIfNot.t.Errorf("RepositoryMock.AddQuestionsIfNot got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddQuestionsIfNot.AddQuestionsIfNotMock.defaultExpectation.results
		if mm_results == nil {
			mmAddQuestionsIfNot.t.Fatal("No results are set for the RepositoryMock.AddQuestionsIfNot")
		}
		return (*mm_results).i2, (*mm_results).err
	}
	if mmAddQuestionsIfNot.funcAddQuestionsIfNot != nil {
		return mmAddQuestionsIfNot.funcAddQuestionsIfNot(ctx, qap1, i1)
	}
	mmAddQuestionsIfNot.t.Fatalf("Unexpected call to RepositoryMock.AddQuestionsIfNot. %v %v %v", ctx, qap1, i1)
	return
}

// AddQuestionsIfNotAfterCounter returns a count of finished RepositoryMock.AddQuestionsIfNot invocations
func (mmAddQuestionsIfNot *RepositoryMock) AddQuestionsIfNotAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddQuestionsIfNot.afterAddQuestionsIfNotCounter)
}

// AddQuestionsIfNotBeforeCounter returns a count of RepositoryMock.AddQuestionsIfNot invocations
func (mmAddQuestionsIfNot *RepositoryMock) AddQuestionsIfNotBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddQuestionsIfNot.beforeAddQuestionsIfNotCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.AddQuestionsIfNot.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddQuestionsIfNot *mRepositoryMockAddQuestionsIfNot) Calls() []*RepositoryMockAddQuestionsIfNotParams {
	mmAddQuestionsIfNot.mutex.RLock()

	argCopy := make([]*RepositoryMockAddQuestionsIfNotParams, len(mmAddQuestionsIfNot.callArgs))
	copy(argCopy, mmAddQuestionsIfNot.callArgs)

	mmAddQuestionsIfNot.mutex.RUnlock()

	return argCopy
}

// MinimockAddQuestionsIfNotDone returns true if the count of the AddQuestionsIfNot invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockAddQuestionsIfNotDone() bool {
	for _, e := range m.AddQuestionsIfNotMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddQuestionsIfNotMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddQuestionsIfNotCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddQuestionsIfNot != nil && mm_atomic.LoadUint64(&m.afterAddQuestionsIfNotCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddQuestionsIfNotInspect logs each unmet expectation
func (m *RepositoryMock) MinimockAddQuestionsIfNotInspect() {
	for _, e := range m.AddQuestionsIfNotMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.AddQuestionsIfNot with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddQuestionsIfNotMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddQuestionsIfNotCounter) < 1 {
		if m.AddQuestionsIfNotMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.AddQuestionsIfNot")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.AddQuestionsIfNot with params: %#v", *m.AddQuestionsIfNotMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddQuestionsIfNot != nil && mm_atomic.LoadUint64(&m.afterAddQuestionsIfNotCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.AddQuestionsIfNot")
	}
}

type mRepositoryMockAddUser struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockAddUserExpectation
	expectations       []*RepositoryMockAddUserExpectation

	callArgs []*RepositoryMockAddUserParams
	mutex    sync.RWMutex
}

// RepositoryMockAddUserExpectation specifies expectation struct of the Repository.AddUser
type RepositoryMockAddUserExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockAddUserParams
	results *RepositoryMockAddUserResults
	Counter uint64
}

// RepositoryMockAddUserParams contains parameters of the Repository.AddUser
type RepositoryMockAddUserParams struct {
	ctx context.Context
	s1  string
}

// RepositoryMockAddUserResults contains results of the Repository.AddUser
type RepositoryMockAddUserResults struct {
	i1  int64
	err error
}

// Expect sets up expected params for Repository.AddUser
func (mmAddUser *mRepositoryMockAddUser) Expect(ctx context.Context, s1 string) *mRepositoryMockAddUser {
	if mmAddUser.mock.funcAddUser != nil {
		mmAddUser.mock.t.Fatalf("RepositoryMock.AddUser mock is already set by Set")
	}

	if mmAddUser.defaultExpectation == nil {
		mmAddUser.defaultExpectation = &RepositoryMockAddUserExpectation{}
	}

	mmAddUser.defaultExpectation.params = &RepositoryMockAddUserParams{ctx, s1}
	for _, e := range mmAddUser.expectations {
		if minimock.Equal(e.params, mmAddUser.defaultExpectation.params) {
			mmAddUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddUser.defaultExpectation.params)
		}
	}

	return mmAddUser
}

// Inspect accepts an inspector function that has same arguments as the Repository.AddUser
func (mmAddUser *mRepositoryMockAddUser) Inspect(f func(ctx context.Context, s1 string)) *mRepositoryMockAddUser {
	if mmAddUser.mock.inspectFuncAddUser != nil {
		mmAddUser.mock.t.Fatalf("Inspect function is already set for RepositoryMock.AddUser")
	}

	mmAddUser.mock.inspectFuncAddUser = f

	return mmAddUser
}

// Return sets up results that will be returned by Repository.AddUser
func (mmAddUser *mRepositoryMockAddUser) Return(i1 int64, err error) *RepositoryMock {
	if mmAddUser.mock.funcAddUser != nil {
		mmAddUser.mock.t.Fatalf("RepositoryMock.AddUser mock is already set by Set")
	}

	if mmAddUser.defaultExpectation == nil {
		mmAddUser.defaultExpectation = &RepositoryMockAddUserExpectation{mock: mmAddUser.mock}
	}
	mmAddUser.defaultExpectation.results = &RepositoryMockAddUserResults{i1, err}
	return mmAddUser.mock
}

//Set uses given function f to mock the Repository.AddUser method
func (mmAddUser *mRepositoryMockAddUser) Set(f func(ctx context.Context, s1 string) (i1 int64, err error)) *RepositoryMock {
	if mmAddUser.defaultExpectation != nil {
		mmAddUser.mock.t.Fatalf("Default expectation is already set for the Repository.AddUser method")
	}

	if len(mmAddUser.expectations) > 0 {
		mmAddUser.mock.t.Fatalf("Some expectations are already set for the Repository.AddUser method")
	}

	mmAddUser.mock.funcAddUser = f
	return mmAddUser.mock
}

// When sets expectation for the Repository.AddUser which will trigger the result defined by the following
// Then helper
func (mmAddUser *mRepositoryMockAddUser) When(ctx context.Context, s1 string) *RepositoryMockAddUserExpectation {
	if mmAddUser.mock.funcAddUser != nil {
		mmAddUser.mock.t.Fatalf("RepositoryMock.AddUser mock is already set by Set")
	}

	expectation := &RepositoryMockAddUserExpectation{
		mock:   mmAddUser.mock,
		params: &RepositoryMockAddUserParams{ctx, s1},
	}
	mmAddUser.expectations = append(mmAddUser.expectations, expectation)
	return expectation
}

// Then sets up Repository.AddUser return parameters for the expectation previously defined by the When method
func (e *RepositoryMockAddUserExpectation) Then(i1 int64, err error) *RepositoryMock {
	e.results = &RepositoryMockAddUserResults{i1, err}
	return e.mock
}

// AddUser implements Repository
func (mmAddUser *RepositoryMock) AddUser(ctx context.Context, s1 string) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmAddUser.beforeAddUserCounter, 1)
	defer mm_atomic.AddUint64(&mmAddUser.afterAddUserCounter, 1)

	if mmAddUser.inspectFuncAddUser != nil {
		mmAddUser.inspectFuncAddUser(ctx, s1)
	}

	mm_params := &RepositoryMockAddUserParams{ctx, s1}

	// Record call args
	mmAddUser.AddUserMock.mutex.Lock()
	mmAddUser.AddUserMock.callArgs = append(mmAddUser.AddUserMock.callArgs, mm_params)
	mmAddUser.AddUserMock.mutex.Unlock()

	for _, e := range mmAddUser.AddUserMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmAddUser.AddUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddUser.AddUserMock.defaultExpectation.Counter, 1)
		mm_want := mmAddUser.AddUserMock.defaultExpectation.params
		mm_got := RepositoryMockAddUserParams{ctx, s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddUser.t.Errorf("RepositoryMock.AddUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddUser.AddUserMock.defaultExpectation.results
		if mm_results == nil {
			mmAddUser.t.Fatal("No results are set for the RepositoryMock.AddUser")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmAddUser.funcAddUser != nil {
		return mmAddUser.funcAddUser(ctx, s1)
	}
	mmAddUser.t.Fatalf("Unexpected call to RepositoryMock.AddUser. %v %v", ctx, s1)
	return
}

// AddUserAfterCounter returns a count of finished RepositoryMock.AddUser invocations
func (mmAddUser *RepositoryMock) AddUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddUser.afterAddUserCounter)
}

// AddUserBeforeCounter returns a count of RepositoryMock.AddUser invocations
func (mmAddUser *RepositoryMock) AddUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddUser.beforeAddUserCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.AddUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddUser *mRepositoryMockAddUser) Calls() []*RepositoryMockAddUserParams {
	mmAddUser.mutex.RLock()

	argCopy := make([]*RepositoryMockAddUserParams, len(mmAddUser.callArgs))
	copy(argCopy, mmAddUser.callArgs)

	mmAddUser.mutex.RUnlock()

	return argCopy
}

// MinimockAddUserDone returns true if the count of the AddUser invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockAddUserDone() bool {
	for _, e := range m.AddUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddUserCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddUser != nil && mm_atomic.LoadUint64(&m.afterAddUserCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddUserInspect logs each unmet expectation
func (m *RepositoryMock) MinimockAddUserInspect() {
	for _, e := range m.AddUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.AddUser with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddUserCounter) < 1 {
		if m.AddUserMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.AddUser")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.AddUser with params: %#v", *m.AddUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddUser != nil && mm_atomic.LoadUint64(&m.afterAddUserCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.AddUser")
	}
}

type mRepositoryMockCheckPartyCompleted struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCheckPartyCompletedExpectation
	expectations       []*RepositoryMockCheckPartyCompletedExpectation

	callArgs []*RepositoryMockCheckPartyCompletedParams
	mutex    sync.RWMutex
}

// RepositoryMockCheckPartyCompletedExpectation specifies expectation struct of the Repository.CheckPartyCompleted
type RepositoryMockCheckPartyCompletedExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockCheckPartyCompletedParams
	results *RepositoryMockCheckPartyCompletedResults
	Counter uint64
}

// RepositoryMockCheckPartyCompletedParams contains parameters of the Repository.CheckPartyCompleted
type RepositoryMockCheckPartyCompletedParams struct {
	ctx     context.Context
	partyID int64
}

// RepositoryMockCheckPartyCompletedResults contains results of the Repository.CheckPartyCompleted
type RepositoryMockCheckPartyCompletedResults struct {
	b1  bool
	err error
}

// Expect sets up expected params for Repository.CheckPartyCompleted
func (mmCheckPartyCompleted *mRepositoryMockCheckPartyCompleted) Expect(ctx context.Context, partyID int64) *mRepositoryMockCheckPartyCompleted {
	if mmCheckPartyCompleted.mock.funcCheckPartyCompleted != nil {
		mmCheckPartyCompleted.mock.t.Fatalf("RepositoryMock.CheckPartyCompleted mock is already set by Set")
	}

	if mmCheckPartyCompleted.defaultExpectation == nil {
		mmCheckPartyCompleted.defaultExpectation = &RepositoryMockCheckPartyCompletedExpectation{}
	}

	mmCheckPartyCompleted.defaultExpectation.params = &RepositoryMockCheckPartyCompletedParams{ctx, partyID}
	for _, e := range mmCheckPartyCompleted.expectations {
		if minimock.Equal(e.params, mmCheckPartyCompleted.defaultExpectation.params) {
			mmCheckPartyCompleted.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCheckPartyCompleted.defaultExpectation.params)
		}
	}

	return mmCheckPartyCompleted
}

// Inspect accepts an inspector function that has same arguments as the Repository.CheckPartyCompleted
func (mmCheckPartyCompleted *mRepositoryMockCheckPartyCompleted) Inspect(f func(ctx context.Context, partyID int64)) *mRepositoryMockCheckPartyCompleted {
	if mmCheckPartyCompleted.mock.inspectFuncCheckPartyCompleted != nil {
		mmCheckPartyCompleted.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CheckPartyCompleted")
	}

	mmCheckPartyCompleted.mock.inspectFuncCheckPartyCompleted = f

	return mmCheckPartyCompleted
}

// Return sets up results that will be returned by Repository.CheckPartyCompleted
func (mmCheckPartyCompleted *mRepositoryMockCheckPartyCompleted) Return(b1 bool, err error) *RepositoryMock {
	if mmCheckPartyCompleted.mock.funcCheckPartyCompleted != nil {
		mmCheckPartyCompleted.mock.t.Fatalf("RepositoryMock.CheckPartyCompleted mock is already set by Set")
	}

	if mmCheckPartyCompleted.defaultExpectation == nil {
		mmCheckPartyCompleted.defaultExpectation = &RepositoryMockCheckPartyCompletedExpectation{mock: mmCheckPartyCompleted.mock}
	}
	mmCheckPartyCompleted.defaultExpectation.results = &RepositoryMockCheckPartyCompletedResults{b1, err}
	return mmCheckPartyCompleted.mock
}

//Set uses given function f to mock the Repository.CheckPartyCompleted method
func (mmCheckPartyCompleted *mRepositoryMockCheckPartyCompleted) Set(f func(ctx context.Context, partyID int64) (b1 bool, err error)) *RepositoryMock {
	if mmCheckPartyCompleted.defaultExpectation != nil {
		mmCheckPartyCompleted.mock.t.Fatalf("Default expectation is already set for the Repository.CheckPartyCompleted method")
	}

	if len(mmCheckPartyCompleted.expectations) > 0 {
		mmCheckPartyCompleted.mock.t.Fatalf("Some expectations are already set for the Repository.CheckPartyCompleted method")
	}

	mmCheckPartyCompleted.mock.funcCheckPartyCompleted = f
	return mmCheckPartyCompleted.mock
}

// When sets expectation for the Repository.CheckPartyCompleted which will trigger the result defined by the following
// Then helper
func (mmCheckPartyCompleted *mRepositoryMockCheckPartyCompleted) When(ctx context.Context, partyID int64) *RepositoryMockCheckPartyCompletedExpectation {
	if mmCheckPartyCompleted.mock.funcCheckPartyCompleted != nil {
		mmCheckPartyCompleted.mock.t.Fatalf("RepositoryMock.CheckPartyCompleted mock is already set by Set")
	}

	expectation := &RepositoryMockCheckPartyCompletedExpectation{
		mock:   mmCheckPartyCompleted.mock,
		params: &RepositoryMockCheckPartyCompletedParams{ctx, partyID},
	}
	mmCheckPartyCompleted.expectations = append(mmCheckPartyCompleted.expectations, expectation)
	return expectation
}

// Then sets up Repository.CheckPartyCompleted return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCheckPartyCompletedExpectation) Then(b1 bool, err error) *RepositoryMock {
	e.results = &RepositoryMockCheckPartyCompletedResults{b1, err}
	return e.mock
}

// CheckPartyCompleted implements Repository
func (mmCheckPartyCompleted *RepositoryMock) CheckPartyCompleted(ctx context.Context, partyID int64) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmCheckPartyCompleted.beforeCheckPartyCompletedCounter, 1)
	defer mm_atomic.AddUint64(&mmCheckPartyCompleted.afterCheckPartyCompletedCounter, 1)

	if mmCheckPartyCompleted.inspectFuncCheckPartyCompleted != nil {
		mmCheckPartyCompleted.inspectFuncCheckPartyCompleted(ctx, partyID)
	}

	mm_params := &RepositoryMockCheckPartyCompletedParams{ctx, partyID}

	// Record call args
	mmCheckPartyCompleted.CheckPartyCompletedMock.mutex.Lock()
	mmCheckPartyCompleted.CheckPartyCompletedMock.callArgs = append(mmCheckPartyCompleted.CheckPartyCompletedMock.callArgs, mm_params)
	mmCheckPartyCompleted.CheckPartyCompletedMock.mutex.Unlock()

	for _, e := range mmCheckPartyCompleted.CheckPartyCompletedMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmCheckPartyCompleted.CheckPartyCompletedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCheckPartyCompleted.CheckPartyCompletedMock.defaultExpectation.Counter, 1)
		mm_want := mmCheckPartyCompleted.CheckPartyCompletedMock.defaultExpectation.params
		mm_got := RepositoryMockCheckPartyCompletedParams{ctx, partyID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCheckPartyCompleted.t.Errorf("RepositoryMock.CheckPartyCompleted got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCheckPartyCompleted.CheckPartyCompletedMock.defaultExpectation.results
		if mm_results == nil {
			mmCheckPartyCompleted.t.Fatal("No results are set for the RepositoryMock.CheckPartyCompleted")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmCheckPartyCompleted.funcCheckPartyCompleted != nil {
		return mmCheckPartyCompleted.funcCheckPartyCompleted(ctx, partyID)
	}
	mmCheckPartyCompleted.t.Fatalf("Unexpected call to RepositoryMock.CheckPartyCompleted. %v %v", ctx, partyID)
	return
}

// CheckPartyCompletedAfterCounter returns a count of finished RepositoryMock.CheckPartyCompleted invocations
func (mmCheckPartyCompleted *RepositoryMock) CheckPartyCompletedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckPartyCompleted.afterCheckPartyCompletedCounter)
}

// CheckPartyCompletedBeforeCounter returns a count of RepositoryMock.CheckPartyCompleted invocations
func (mmCheckPartyCompleted *RepositoryMock) CheckPartyCompletedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckPartyCompleted.beforeCheckPartyCompletedCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CheckPartyCompleted.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCheckPartyCompleted *mRepositoryMockCheckPartyCompleted) Calls() []*RepositoryMockCheckPartyCompletedParams {
	mmCheckPartyCompleted.mutex.RLock()

	argCopy := make([]*RepositoryMockCheckPartyCompletedParams, len(mmCheckPartyCompleted.callArgs))
	copy(argCopy, mmCheckPartyCompleted.callArgs)

	mmCheckPartyCompleted.mutex.RUnlock()

	return argCopy
}

// MinimockCheckPartyCompletedDone returns true if the count of the CheckPartyCompleted invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCheckPartyCompletedDone() bool {
	for _, e := range m.CheckPartyCompletedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CheckPartyCompletedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCheckPartyCompletedCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheckPartyCompleted != nil && mm_atomic.LoadUint64(&m.afterCheckPartyCompletedCounter) < 1 {
		return false
	}
	return true
}

// MinimockCheckPartyCompletedInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCheckPartyCompletedInspect() {
	for _, e := range m.CheckPartyCompletedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CheckPartyCompleted with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CheckPartyCompletedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCheckPartyCompletedCounter) < 1 {
		if m.CheckPartyCompletedMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.CheckPartyCompleted")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CheckPartyCompleted with params: %#v", *m.CheckPartyCompletedMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheckPartyCompleted != nil && mm_atomic.LoadUint64(&m.afterCheckPartyCompletedCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.CheckPartyCompleted")
	}
}

type mRepositoryMockCompleteParty struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCompletePartyExpectation
	expectations       []*RepositoryMockCompletePartyExpectation

	callArgs []*RepositoryMockCompletePartyParams
	mutex    sync.RWMutex
}

// RepositoryMockCompletePartyExpectation specifies expectation struct of the Repository.CompleteParty
type RepositoryMockCompletePartyExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockCompletePartyParams
	results *RepositoryMockCompletePartyResults
	Counter uint64
}

// RepositoryMockCompletePartyParams contains parameters of the Repository.CompleteParty
type RepositoryMockCompletePartyParams struct {
	ctx     context.Context
	partyID int64
	points  int32
}

// RepositoryMockCompletePartyResults contains results of the Repository.CompleteParty
type RepositoryMockCompletePartyResults struct {
	s1  models.SingleTop
	err error
}

// Expect sets up expected params for Repository.CompleteParty
func (mmCompleteParty *mRepositoryMockCompleteParty) Expect(ctx context.Context, partyID int64, points int32) *mRepositoryMockCompleteParty {
	if mmCompleteParty.mock.funcCompleteParty != nil {
		mmCompleteParty.mock.t.Fatalf("RepositoryMock.CompleteParty mock is already set by Set")
	}

	if mmCompleteParty.defaultExpectation == nil {
		mmCompleteParty.defaultExpectation = &RepositoryMockCompletePartyExpectation{}
	}

	mmCompleteParty.defaultExpectation.params = &RepositoryMockCompletePartyParams{ctx, partyID, points}
	for _, e := range mmCompleteParty.expectations {
		if minimock.Equal(e.params, mmCompleteParty.defaultExpectation.params) {
			mmCompleteParty.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCompleteParty.defaultExpectation.params)
		}
	}

	return mmCompleteParty
}

// Inspect accepts an inspector function that has same arguments as the Repository.CompleteParty
func (mmCompleteParty *mRepositoryMockCompleteParty) Inspect(f func(ctx context.Context, partyID int64, points int32)) *mRepositoryMockCompleteParty {
	if mmCompleteParty.mock.inspectFuncCompleteParty != nil {
		mmCompleteParty.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CompleteParty")
	}

	mmCompleteParty.mock.inspectFuncCompleteParty = f

	return mmCompleteParty
}

// Return sets up results that will be returned by Repository.CompleteParty
func (mmCompleteParty *mRepositoryMockCompleteParty) Return(s1 models.SingleTop, err error) *RepositoryMock {
	if mmCompleteParty.mock.funcCompleteParty != nil {
		mmCompleteParty.mock.t.Fatalf("RepositoryMock.CompleteParty mock is already set by Set")
	}

	if mmCompleteParty.defaultExpectation == nil {
		mmCompleteParty.defaultExpectation = &RepositoryMockCompletePartyExpectation{mock: mmCompleteParty.mock}
	}
	mmCompleteParty.defaultExpectation.results = &RepositoryMockCompletePartyResults{s1, err}
	return mmCompleteParty.mock
}

//Set uses given function f to mock the Repository.CompleteParty method
func (mmCompleteParty *mRepositoryMockCompleteParty) Set(f func(ctx context.Context, partyID int64, points int32) (s1 models.SingleTop, err error)) *RepositoryMock {
	if mmCompleteParty.defaultExpectation != nil {
		mmCompleteParty.mock.t.Fatalf("Default expectation is already set for the Repository.CompleteParty method")
	}

	if len(mmCompleteParty.expectations) > 0 {
		mmCompleteParty.mock.t.Fatalf("Some expectations are already set for the Repository.CompleteParty method")
	}

	mmCompleteParty.mock.funcCompleteParty = f
	return mmCompleteParty.mock
}

// When sets expectation for the Repository.CompleteParty which will trigger the result defined by the following
// Then helper
func (mmCompleteParty *mRepositoryMockCompleteParty) When(ctx context.Context, partyID int64, points int32) *RepositoryMockCompletePartyExpectation {
	if mmCompleteParty.mock.funcCompleteParty != nil {
		mmCompleteParty.mock.t.Fatalf("RepositoryMock.CompleteParty mock is already set by Set")
	}

	expectation := &RepositoryMockCompletePartyExpectation{
		mock:   mmCompleteParty.mock,
		params: &RepositoryMockCompletePartyParams{ctx, partyID, points},
	}
	mmCompleteParty.expectations = append(mmCompleteParty.expectations, expectation)
	return expectation
}

// Then sets up Repository.CompleteParty return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCompletePartyExpectation) Then(s1 models.SingleTop, err error) *RepositoryMock {
	e.results = &RepositoryMockCompletePartyResults{s1, err}
	return e.mock
}

// CompleteParty implements Repository
func (mmCompleteParty *RepositoryMock) CompleteParty(ctx context.Context, partyID int64, points int32) (s1 models.SingleTop, err error) {
	mm_atomic.AddUint64(&mmCompleteParty.beforeCompletePartyCounter, 1)
	defer mm_atomic.AddUint64(&mmCompleteParty.afterCompletePartyCounter, 1)

	if mmCompleteParty.inspectFuncCompleteParty != nil {
		mmCompleteParty.inspectFuncCompleteParty(ctx, partyID, points)
	}

	mm_params := &RepositoryMockCompletePartyParams{ctx, partyID, points}

	// Record call args
	mmCompleteParty.CompletePartyMock.mutex.Lock()
	mmCompleteParty.CompletePartyMock.callArgs = append(mmCompleteParty.CompletePartyMock.callArgs, mm_params)
	mmCompleteParty.CompletePartyMock.mutex.Unlock()

	for _, e := range mmCompleteParty.CompletePartyMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmCompleteParty.CompletePartyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCompleteParty.CompletePartyMock.defaultExpectation.Counter, 1)
		mm_want := mmCompleteParty.CompletePartyMock.defaultExpectation.params
		mm_got := RepositoryMockCompletePartyParams{ctx, partyID, points}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCompleteParty.t.Errorf("RepositoryMock.CompleteParty got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCompleteParty.CompletePartyMock.defaultExpectation.results
		if mm_results == nil {
			mmCompleteParty.t.Fatal("No results are set for the RepositoryMock.CompleteParty")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmCompleteParty.funcCompleteParty != nil {
		return mmCompleteParty.funcCompleteParty(ctx, partyID, points)
	}
	mmCompleteParty.t.Fatalf("Unexpected call to RepositoryMock.CompleteParty. %v %v %v", ctx, partyID, points)
	return
}

// CompletePartyAfterCounter returns a count of finished RepositoryMock.CompleteParty invocations
func (mmCompleteParty *RepositoryMock) CompletePartyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCompleteParty.afterCompletePartyCounter)
}

// CompletePartyBeforeCounter returns a count of RepositoryMock.CompleteParty invocations
func (mmCompleteParty *RepositoryMock) CompletePartyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCompleteParty.beforeCompletePartyCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CompleteParty.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCompleteParty *mRepositoryMockCompleteParty) Calls() []*RepositoryMockCompletePartyParams {
	mmCompleteParty.mutex.RLock()

	argCopy := make([]*RepositoryMockCompletePartyParams, len(mmCompleteParty.callArgs))
	copy(argCopy, mmCompleteParty.callArgs)

	mmCompleteParty.mutex.RUnlock()

	return argCopy
}

// MinimockCompletePartyDone returns true if the count of the CompleteParty invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCompletePartyDone() bool {
	for _, e := range m.CompletePartyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CompletePartyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCompletePartyCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCompleteParty != nil && mm_atomic.LoadUint64(&m.afterCompletePartyCounter) < 1 {
		return false
	}
	return true
}

// MinimockCompletePartyInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCompletePartyInspect() {
	for _, e := range m.CompletePartyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CompleteParty with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CompletePartyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCompletePartyCounter) < 1 {
		if m.CompletePartyMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.CompleteParty")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CompleteParty with params: %#v", *m.CompletePartyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCompleteParty != nil && mm_atomic.LoadUint64(&m.afterCompletePartyCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.CompleteParty")
	}
}

type mRepositoryMockGetQuiz struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetQuizExpectation
	expectations       []*RepositoryMockGetQuizExpectation

	callArgs []*RepositoryMockGetQuizParams
	mutex    sync.RWMutex
}

// RepositoryMockGetQuizExpectation specifies expectation struct of the Repository.GetQuiz
type RepositoryMockGetQuizExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockGetQuizParams
	results *RepositoryMockGetQuizResults
	Counter uint64
}

// RepositoryMockGetQuizParams contains parameters of the Repository.GetQuiz
type RepositoryMockGetQuizParams struct {
	ctx context.Context
	i1  int64
}

// RepositoryMockGetQuizResults contains results of the Repository.GetQuiz
type RepositoryMockGetQuizResults struct {
	q1  models.Quiz
	err error
}

// Expect sets up expected params for Repository.GetQuiz
func (mmGetQuiz *mRepositoryMockGetQuiz) Expect(ctx context.Context, i1 int64) *mRepositoryMockGetQuiz {
	if mmGetQuiz.mock.funcGetQuiz != nil {
		mmGetQuiz.mock.t.Fatalf("RepositoryMock.GetQuiz mock is already set by Set")
	}

	if mmGetQuiz.defaultExpectation == nil {
		mmGetQuiz.defaultExpectation = &RepositoryMockGetQuizExpectation{}
	}

	mmGetQuiz.defaultExpectation.params = &RepositoryMockGetQuizParams{ctx, i1}
	for _, e := range mmGetQuiz.expectations {
		if minimock.Equal(e.params, mmGetQuiz.defaultExpectation.params) {
			mmGetQuiz.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetQuiz.defaultExpectation.params)
		}
	}

	return mmGetQuiz
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetQuiz
func (mmGetQuiz *mRepositoryMockGetQuiz) Inspect(f func(ctx context.Context, i1 int64)) *mRepositoryMockGetQuiz {
	if mmGetQuiz.mock.inspectFuncGetQuiz != nil {
		mmGetQuiz.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetQuiz")
	}

	mmGetQuiz.mock.inspectFuncGetQuiz = f

	return mmGetQuiz
}

// Return sets up results that will be returned by Repository.GetQuiz
func (mmGetQuiz *mRepositoryMockGetQuiz) Return(q1 models.Quiz, err error) *RepositoryMock {
	if mmGetQuiz.mock.funcGetQuiz != nil {
		mmGetQuiz.mock.t.Fatalf("RepositoryMock.GetQuiz mock is already set by Set")
	}

	if mmGetQuiz.defaultExpectation == nil {
		mmGetQuiz.defaultExpectation = &RepositoryMockGetQuizExpectation{mock: mmGetQuiz.mock}
	}
	mmGetQuiz.defaultExpectation.results = &RepositoryMockGetQuizResults{q1, err}
	return mmGetQuiz.mock
}

//Set uses given function f to mock the Repository.GetQuiz method
func (mmGetQuiz *mRepositoryMockGetQuiz) Set(f func(ctx context.Context, i1 int64) (q1 models.Quiz, err error)) *RepositoryMock {
	if mmGetQuiz.defaultExpectation != nil {
		mmGetQuiz.mock.t.Fatalf("Default expectation is already set for the Repository.GetQuiz method")
	}

	if len(mmGetQuiz.expectations) > 0 {
		mmGetQuiz.mock.t.Fatalf("Some expectations are already set for the Repository.GetQuiz method")
	}

	mmGetQuiz.mock.funcGetQuiz = f
	return mmGetQuiz.mock
}

// When sets expectation for the Repository.GetQuiz which will trigger the result defined by the following
// Then helper
func (mmGetQuiz *mRepositoryMockGetQuiz) When(ctx context.Context, i1 int64) *RepositoryMockGetQuizExpectation {
	if mmGetQuiz.mock.funcGetQuiz != nil {
		mmGetQuiz.mock.t.Fatalf("RepositoryMock.GetQuiz mock is already set by Set")
	}

	expectation := &RepositoryMockGetQuizExpectation{
		mock:   mmGetQuiz.mock,
		params: &RepositoryMockGetQuizParams{ctx, i1},
	}
	mmGetQuiz.expectations = append(mmGetQuiz.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetQuiz return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetQuizExpectation) Then(q1 models.Quiz, err error) *RepositoryMock {
	e.results = &RepositoryMockGetQuizResults{q1, err}
	return e.mock
}

// GetQuiz implements Repository
func (mmGetQuiz *RepositoryMock) GetQuiz(ctx context.Context, i1 int64) (q1 models.Quiz, err error) {
	mm_atomic.AddUint64(&mmGetQuiz.beforeGetQuizCounter, 1)
	defer mm_atomic.AddUint64(&mmGetQuiz.afterGetQuizCounter, 1)

	if mmGetQuiz.inspectFuncGetQuiz != nil {
		mmGetQuiz.inspectFuncGetQuiz(ctx, i1)
	}

	mm_params := &RepositoryMockGetQuizParams{ctx, i1}

	// Record call args
	mmGetQuiz.GetQuizMock.mutex.Lock()
	mmGetQuiz.GetQuizMock.callArgs = append(mmGetQuiz.GetQuizMock.callArgs, mm_params)
	mmGetQuiz.GetQuizMock.mutex.Unlock()

	for _, e := range mmGetQuiz.GetQuizMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.q1, e.results.err
		}
	}

	if mmGetQuiz.GetQuizMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetQuiz.GetQuizMock.defaultExpectation.Counter, 1)
		mm_want := mmGetQuiz.GetQuizMock.defaultExpectation.params
		mm_got := RepositoryMockGetQuizParams{ctx, i1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetQuiz.t.Errorf("RepositoryMock.GetQuiz got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetQuiz.GetQuizMock.defaultExpectation.results
		if mm_results == nil {
			mmGetQuiz.t.Fatal("No results are set for the RepositoryMock.GetQuiz")
		}
		return (*mm_results).q1, (*mm_results).err
	}
	if mmGetQuiz.funcGetQuiz != nil {
		return mmGetQuiz.funcGetQuiz(ctx, i1)
	}
	mmGetQuiz.t.Fatalf("Unexpected call to RepositoryMock.GetQuiz. %v %v", ctx, i1)
	return
}

// GetQuizAfterCounter returns a count of finished RepositoryMock.GetQuiz invocations
func (mmGetQuiz *RepositoryMock) GetQuizAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetQuiz.afterGetQuizCounter)
}

// GetQuizBeforeCounter returns a count of RepositoryMock.GetQuiz invocations
func (mmGetQuiz *RepositoryMock) GetQuizBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetQuiz.beforeGetQuizCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetQuiz.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetQuiz *mRepositoryMockGetQuiz) Calls() []*RepositoryMockGetQuizParams {
	mmGetQuiz.mutex.RLock()

	argCopy := make([]*RepositoryMockGetQuizParams, len(mmGetQuiz.callArgs))
	copy(argCopy, mmGetQuiz.callArgs)

	mmGetQuiz.mutex.RUnlock()

	return argCopy
}

// MinimockGetQuizDone returns true if the count of the GetQuiz invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetQuizDone() bool {
	for _, e := range m.GetQuizMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetQuizMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetQuizCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetQuiz != nil && mm_atomic.LoadUint64(&m.afterGetQuizCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetQuizInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetQuizInspect() {
	for _, e := range m.GetQuizMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetQuiz with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetQuizMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetQuizCounter) < 1 {
		if m.GetQuizMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.GetQuiz")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetQuiz with params: %#v", *m.GetQuizMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetQuiz != nil && mm_atomic.LoadUint64(&m.afterGetQuizCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.GetQuiz")
	}
}

type mRepositoryMockGetQuizList struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetQuizListExpectation
	expectations       []*RepositoryMockGetQuizListExpectation

	callArgs []*RepositoryMockGetQuizListParams
	mutex    sync.RWMutex
}

// RepositoryMockGetQuizListExpectation specifies expectation struct of the Repository.GetQuizList
type RepositoryMockGetQuizListExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockGetQuizListParams
	results *RepositoryMockGetQuizListResults
	Counter uint64
}

// RepositoryMockGetQuizListParams contains parameters of the Repository.GetQuizList
type RepositoryMockGetQuizListParams struct {
	ctx context.Context
}

// RepositoryMockGetQuizListResults contains results of the Repository.GetQuizList
type RepositoryMockGetQuizListResults struct {
	qa1 []models.Quiz
	err error
}

// Expect sets up expected params for Repository.GetQuizList
func (mmGetQuizList *mRepositoryMockGetQuizList) Expect(ctx context.Context) *mRepositoryMockGetQuizList {
	if mmGetQuizList.mock.funcGetQuizList != nil {
		mmGetQuizList.mock.t.Fatalf("RepositoryMock.GetQuizList mock is already set by Set")
	}

	if mmGetQuizList.defaultExpectation == nil {
		mmGetQuizList.defaultExpectation = &RepositoryMockGetQuizListExpectation{}
	}

	mmGetQuizList.defaultExpectation.params = &RepositoryMockGetQuizListParams{ctx}
	for _, e := range mmGetQuizList.expectations {
		if minimock.Equal(e.params, mmGetQuizList.defaultExpectation.params) {
			mmGetQuizList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetQuizList.defaultExpectation.params)
		}
	}

	return mmGetQuizList
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetQuizList
func (mmGetQuizList *mRepositoryMockGetQuizList) Inspect(f func(ctx context.Context)) *mRepositoryMockGetQuizList {
	if mmGetQuizList.mock.inspectFuncGetQuizList != nil {
		mmGetQuizList.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetQuizList")
	}

	mmGetQuizList.mock.inspectFuncGetQuizList = f

	return mmGetQuizList
}

// Return sets up results that will be returned by Repository.GetQuizList
func (mmGetQuizList *mRepositoryMockGetQuizList) Return(qa1 []models.Quiz, err error) *RepositoryMock {
	if mmGetQuizList.mock.funcGetQuizList != nil {
		mmGetQuizList.mock.t.Fatalf("RepositoryMock.GetQuizList mock is already set by Set")
	}

	if mmGetQuizList.defaultExpectation == nil {
		mmGetQuizList.defaultExpectation = &RepositoryMockGetQuizListExpectation{mock: mmGetQuizList.mock}
	}
	mmGetQuizList.defaultExpectation.results = &RepositoryMockGetQuizListResults{qa1, err}
	return mmGetQuizList.mock
}

//Set uses given function f to mock the Repository.GetQuizList method
func (mmGetQuizList *mRepositoryMockGetQuizList) Set(f func(ctx context.Context) (qa1 []models.Quiz, err error)) *RepositoryMock {
	if mmGetQuizList.defaultExpectation != nil {
		mmGetQuizList.mock.t.Fatalf("Default expectation is already set for the Repository.GetQuizList method")
	}

	if len(mmGetQuizList.expectations) > 0 {
		mmGetQuizList.mock.t.Fatalf("Some expectations are already set for the Repository.GetQuizList method")
	}

	mmGetQuizList.mock.funcGetQuizList = f
	return mmGetQuizList.mock
}

// When sets expectation for the Repository.GetQuizList which will trigger the result defined by the following
// Then helper
func (mmGetQuizList *mRepositoryMockGetQuizList) When(ctx context.Context) *RepositoryMockGetQuizListExpectation {
	if mmGetQuizList.mock.funcGetQuizList != nil {
		mmGetQuizList.mock.t.Fatalf("RepositoryMock.GetQuizList mock is already set by Set")
	}

	expectation := &RepositoryMockGetQuizListExpectation{
		mock:   mmGetQuizList.mock,
		params: &RepositoryMockGetQuizListParams{ctx},
	}
	mmGetQuizList.expectations = append(mmGetQuizList.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetQuizList return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetQuizListExpectation) Then(qa1 []models.Quiz, err error) *RepositoryMock {
	e.results = &RepositoryMockGetQuizListResults{qa1, err}
	return e.mock
}

// GetQuizList implements Repository
func (mmGetQuizList *RepositoryMock) GetQuizList(ctx context.Context) (qa1 []models.Quiz, err error) {
	mm_atomic.AddUint64(&mmGetQuizList.beforeGetQuizListCounter, 1)
	defer mm_atomic.AddUint64(&mmGetQuizList.afterGetQuizListCounter, 1)

	if mmGetQuizList.inspectFuncGetQuizList != nil {
		mmGetQuizList.inspectFuncGetQuizList(ctx)
	}

	mm_params := &RepositoryMockGetQuizListParams{ctx}

	// Record call args
	mmGetQuizList.GetQuizListMock.mutex.Lock()
	mmGetQuizList.GetQuizListMock.callArgs = append(mmGetQuizList.GetQuizListMock.callArgs, mm_params)
	mmGetQuizList.GetQuizListMock.mutex.Unlock()

	for _, e := range mmGetQuizList.GetQuizListMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.qa1, e.results.err
		}
	}

	if mmGetQuizList.GetQuizListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetQuizList.GetQuizListMock.defaultExpectation.Counter, 1)
		mm_want := mmGetQuizList.GetQuizListMock.defaultExpectation.params
		mm_got := RepositoryMockGetQuizListParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetQuizList.t.Errorf("RepositoryMock.GetQuizList got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetQuizList.GetQuizListMock.defaultExpectation.results
		if mm_results == nil {
			mmGetQuizList.t.Fatal("No results are set for the RepositoryMock.GetQuizList")
		}
		return (*mm_results).qa1, (*mm_results).err
	}
	if mmGetQuizList.funcGetQuizList != nil {
		return mmGetQuizList.funcGetQuizList(ctx)
	}
	mmGetQuizList.t.Fatalf("Unexpected call to RepositoryMock.GetQuizList. %v", ctx)
	return
}

// GetQuizListAfterCounter returns a count of finished RepositoryMock.GetQuizList invocations
func (mmGetQuizList *RepositoryMock) GetQuizListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetQuizList.afterGetQuizListCounter)
}

// GetQuizListBeforeCounter returns a count of RepositoryMock.GetQuizList invocations
func (mmGetQuizList *RepositoryMock) GetQuizListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetQuizList.beforeGetQuizListCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetQuizList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetQuizList *mRepositoryMockGetQuizList) Calls() []*RepositoryMockGetQuizListParams {
	mmGetQuizList.mutex.RLock()

	argCopy := make([]*RepositoryMockGetQuizListParams, len(mmGetQuizList.callArgs))
	copy(argCopy, mmGetQuizList.callArgs)

	mmGetQuizList.mutex.RUnlock()

	return argCopy
}

// MinimockGetQuizListDone returns true if the count of the GetQuizList invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetQuizListDone() bool {
	for _, e := range m.GetQuizListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetQuizListMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetQuizListCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetQuizList != nil && mm_atomic.LoadUint64(&m.afterGetQuizListCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetQuizListInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetQuizListInspect() {
	for _, e := range m.GetQuizListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetQuizList with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetQuizListMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetQuizListCounter) < 1 {
		if m.GetQuizListMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.GetQuizList")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetQuizList with params: %#v", *m.GetQuizListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetQuizList != nil && mm_atomic.LoadUint64(&m.afterGetQuizListCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.GetQuizList")
	}
}

type mRepositoryMockGetQuizTop struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetQuizTopExpectation
	expectations       []*RepositoryMockGetQuizTopExpectation

	callArgs []*RepositoryMockGetQuizTopParams
	mutex    sync.RWMutex
}

// RepositoryMockGetQuizTopExpectation specifies expectation struct of the Repository.GetQuizTop
type RepositoryMockGetQuizTopExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockGetQuizTopParams
	results *RepositoryMockGetQuizTopResults
	Counter uint64
}

// RepositoryMockGetQuizTopParams contains parameters of the Repository.GetQuizTop
type RepositoryMockGetQuizTopParams struct {
	ctx    context.Context
	quizID int64
}

// RepositoryMockGetQuizTopResults contains results of the Repository.GetQuizTop
type RepositoryMockGetQuizTopResults struct {
	g1  models.GlobalTop
	err error
}

// Expect sets up expected params for Repository.GetQuizTop
func (mmGetQuizTop *mRepositoryMockGetQuizTop) Expect(ctx context.Context, quizID int64) *mRepositoryMockGetQuizTop {
	if mmGetQuizTop.mock.funcGetQuizTop != nil {
		mmGetQuizTop.mock.t.Fatalf("RepositoryMock.GetQuizTop mock is already set by Set")
	}

	if mmGetQuizTop.defaultExpectation == nil {
		mmGetQuizTop.defaultExpectation = &RepositoryMockGetQuizTopExpectation{}
	}

	mmGetQuizTop.defaultExpectation.params = &RepositoryMockGetQuizTopParams{ctx, quizID}
	for _, e := range mmGetQuizTop.expectations {
		if minimock.Equal(e.params, mmGetQuizTop.defaultExpectation.params) {
			mmGetQuizTop.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetQuizTop.defaultExpectation.params)
		}
	}

	return mmGetQuizTop
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetQuizTop
func (mmGetQuizTop *mRepositoryMockGetQuizTop) Inspect(f func(ctx context.Context, quizID int64)) *mRepositoryMockGetQuizTop {
	if mmGetQuizTop.mock.inspectFuncGetQuizTop != nil {
		mmGetQuizTop.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetQuizTop")
	}

	mmGetQuizTop.mock.inspectFuncGetQuizTop = f

	return mmGetQuizTop
}

// Return sets up results that will be returned by Repository.GetQuizTop
func (mmGetQuizTop *mRepositoryMockGetQuizTop) Return(g1 models.GlobalTop, err error) *RepositoryMock {
	if mmGetQuizTop.mock.funcGetQuizTop != nil {
		mmGetQuizTop.mock.t.Fatalf("RepositoryMock.GetQuizTop mock is already set by Set")
	}

	if mmGetQuizTop.defaultExpectation == nil {
		mmGetQuizTop.defaultExpectation = &RepositoryMockGetQuizTopExpectation{mock: mmGetQuizTop.mock}
	}
	mmGetQuizTop.defaultExpectation.results = &RepositoryMockGetQuizTopResults{g1, err}
	return mmGetQuizTop.mock
}

//Set uses given function f to mock the Repository.GetQuizTop method
func (mmGetQuizTop *mRepositoryMockGetQuizTop) Set(f func(ctx context.Context, quizID int64) (g1 models.GlobalTop, err error)) *RepositoryMock {
	if mmGetQuizTop.defaultExpectation != nil {
		mmGetQuizTop.mock.t.Fatalf("Default expectation is already set for the Repository.GetQuizTop method")
	}

	if len(mmGetQuizTop.expectations) > 0 {
		mmGetQuizTop.mock.t.Fatalf("Some expectations are already set for the Repository.GetQuizTop method")
	}

	mmGetQuizTop.mock.funcGetQuizTop = f
	return mmGetQuizTop.mock
}

// When sets expectation for the Repository.GetQuizTop which will trigger the result defined by the following
// Then helper
func (mmGetQuizTop *mRepositoryMockGetQuizTop) When(ctx context.Context, quizID int64) *RepositoryMockGetQuizTopExpectation {
	if mmGetQuizTop.mock.funcGetQuizTop != nil {
		mmGetQuizTop.mock.t.Fatalf("RepositoryMock.GetQuizTop mock is already set by Set")
	}

	expectation := &RepositoryMockGetQuizTopExpectation{
		mock:   mmGetQuizTop.mock,
		params: &RepositoryMockGetQuizTopParams{ctx, quizID},
	}
	mmGetQuizTop.expectations = append(mmGetQuizTop.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetQuizTop return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetQuizTopExpectation) Then(g1 models.GlobalTop, err error) *RepositoryMock {
	e.results = &RepositoryMockGetQuizTopResults{g1, err}
	return e.mock
}

// GetQuizTop implements Repository
func (mmGetQuizTop *RepositoryMock) GetQuizTop(ctx context.Context, quizID int64) (g1 models.GlobalTop, err error) {
	mm_atomic.AddUint64(&mmGetQuizTop.beforeGetQuizTopCounter, 1)
	defer mm_atomic.AddUint64(&mmGetQuizTop.afterGetQuizTopCounter, 1)

	if mmGetQuizTop.inspectFuncGetQuizTop != nil {
		mmGetQuizTop.inspectFuncGetQuizTop(ctx, quizID)
	}

	mm_params := &RepositoryMockGetQuizTopParams{ctx, quizID}

	// Record call args
	mmGetQuizTop.GetQuizTopMock.mutex.Lock()
	mmGetQuizTop.GetQuizTopMock.callArgs = append(mmGetQuizTop.GetQuizTopMock.callArgs, mm_params)
	mmGetQuizTop.GetQuizTopMock.mutex.Unlock()

	for _, e := range mmGetQuizTop.GetQuizTopMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.g1, e.results.err
		}
	}

	if mmGetQuizTop.GetQuizTopMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetQuizTop.GetQuizTopMock.defaultExpectation.Counter, 1)
		mm_want := mmGetQuizTop.GetQuizTopMock.defaultExpectation.params
		mm_got := RepositoryMockGetQuizTopParams{ctx, quizID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetQuizTop.t.Errorf("RepositoryMock.GetQuizTop got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetQuizTop.GetQuizTopMock.defaultExpectation.results
		if mm_results == nil {
			mmGetQuizTop.t.Fatal("No results are set for the RepositoryMock.GetQuizTop")
		}
		return (*mm_results).g1, (*mm_results).err
	}
	if mmGetQuizTop.funcGetQuizTop != nil {
		return mmGetQuizTop.funcGetQuizTop(ctx, quizID)
	}
	mmGetQuizTop.t.Fatalf("Unexpected call to RepositoryMock.GetQuizTop. %v %v", ctx, quizID)
	return
}

// GetQuizTopAfterCounter returns a count of finished RepositoryMock.GetQuizTop invocations
func (mmGetQuizTop *RepositoryMock) GetQuizTopAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetQuizTop.afterGetQuizTopCounter)
}

// GetQuizTopBeforeCounter returns a count of RepositoryMock.GetQuizTop invocations
func (mmGetQuizTop *RepositoryMock) GetQuizTopBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetQuizTop.beforeGetQuizTopCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetQuizTop.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetQuizTop *mRepositoryMockGetQuizTop) Calls() []*RepositoryMockGetQuizTopParams {
	mmGetQuizTop.mutex.RLock()

	argCopy := make([]*RepositoryMockGetQuizTopParams, len(mmGetQuizTop.callArgs))
	copy(argCopy, mmGetQuizTop.callArgs)

	mmGetQuizTop.mutex.RUnlock()

	return argCopy
}

// MinimockGetQuizTopDone returns true if the count of the GetQuizTop invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetQuizTopDone() bool {
	for _, e := range m.GetQuizTopMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetQuizTopMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetQuizTopCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetQuizTop != nil && mm_atomic.LoadUint64(&m.afterGetQuizTopCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetQuizTopInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetQuizTopInspect() {
	for _, e := range m.GetQuizTopMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetQuizTop with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetQuizTopMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetQuizTopCounter) < 1 {
		if m.GetQuizTopMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.GetQuizTop")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetQuizTop with params: %#v", *m.GetQuizTopMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetQuizTop != nil && mm_atomic.LoadUint64(&m.afterGetQuizTopCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.GetQuizTop")
	}
}

type mRepositoryMockGetRightAnswers struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetRightAnswersExpectation
	expectations       []*RepositoryMockGetRightAnswersExpectation

	callArgs []*RepositoryMockGetRightAnswersParams
	mutex    sync.RWMutex
}

// RepositoryMockGetRightAnswersExpectation specifies expectation struct of the Repository.GetRightAnswers
type RepositoryMockGetRightAnswersExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockGetRightAnswersParams
	results *RepositoryMockGetRightAnswersResults
	Counter uint64
}

// RepositoryMockGetRightAnswersParams contains parameters of the Repository.GetRightAnswers
type RepositoryMockGetRightAnswersParams struct {
	ctx     context.Context
	partyID int64
}

// RepositoryMockGetRightAnswersResults contains results of the Repository.GetRightAnswers
type RepositoryMockGetRightAnswersResults struct {
	iaa1 [][]int32
	err  error
}

// Expect sets up expected params for Repository.GetRightAnswers
func (mmGetRightAnswers *mRepositoryMockGetRightAnswers) Expect(ctx context.Context, partyID int64) *mRepositoryMockGetRightAnswers {
	if mmGetRightAnswers.mock.funcGetRightAnswers != nil {
		mmGetRightAnswers.mock.t.Fatalf("RepositoryMock.GetRightAnswers mock is already set by Set")
	}

	if mmGetRightAnswers.defaultExpectation == nil {
		mmGetRightAnswers.defaultExpectation = &RepositoryMockGetRightAnswersExpectation{}
	}

	mmGetRightAnswers.defaultExpectation.params = &RepositoryMockGetRightAnswersParams{ctx, partyID}
	for _, e := range mmGetRightAnswers.expectations {
		if minimock.Equal(e.params, mmGetRightAnswers.defaultExpectation.params) {
			mmGetRightAnswers.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetRightAnswers.defaultExpectation.params)
		}
	}

	return mmGetRightAnswers
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetRightAnswers
func (mmGetRightAnswers *mRepositoryMockGetRightAnswers) Inspect(f func(ctx context.Context, partyID int64)) *mRepositoryMockGetRightAnswers {
	if mmGetRightAnswers.mock.inspectFuncGetRightAnswers != nil {
		mmGetRightAnswers.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetRightAnswers")
	}

	mmGetRightAnswers.mock.inspectFuncGetRightAnswers = f

	return mmGetRightAnswers
}

// Return sets up results that will be returned by Repository.GetRightAnswers
func (mmGetRightAnswers *mRepositoryMockGetRightAnswers) Return(iaa1 [][]int32, err error) *RepositoryMock {
	if mmGetRightAnswers.mock.funcGetRightAnswers != nil {
		mmGetRightAnswers.mock.t.Fatalf("RepositoryMock.GetRightAnswers mock is already set by Set")
	}

	if mmGetRightAnswers.defaultExpectation == nil {
		mmGetRightAnswers.defaultExpectation = &RepositoryMockGetRightAnswersExpectation{mock: mmGetRightAnswers.mock}
	}
	mmGetRightAnswers.defaultExpectation.results = &RepositoryMockGetRightAnswersResults{iaa1, err}
	return mmGetRightAnswers.mock
}

//Set uses given function f to mock the Repository.GetRightAnswers method
func (mmGetRightAnswers *mRepositoryMockGetRightAnswers) Set(f func(ctx context.Context, partyID int64) (iaa1 [][]int32, err error)) *RepositoryMock {
	if mmGetRightAnswers.defaultExpectation != nil {
		mmGetRightAnswers.mock.t.Fatalf("Default expectation is already set for the Repository.GetRightAnswers method")
	}

	if len(mmGetRightAnswers.expectations) > 0 {
		mmGetRightAnswers.mock.t.Fatalf("Some expectations are already set for the Repository.GetRightAnswers method")
	}

	mmGetRightAnswers.mock.funcGetRightAnswers = f
	return mmGetRightAnswers.mock
}

// When sets expectation for the Repository.GetRightAnswers which will trigger the result defined by the following
// Then helper
func (mmGetRightAnswers *mRepositoryMockGetRightAnswers) When(ctx context.Context, partyID int64) *RepositoryMockGetRightAnswersExpectation {
	if mmGetRightAnswers.mock.funcGetRightAnswers != nil {
		mmGetRightAnswers.mock.t.Fatalf("RepositoryMock.GetRightAnswers mock is already set by Set")
	}

	expectation := &RepositoryMockGetRightAnswersExpectation{
		mock:   mmGetRightAnswers.mock,
		params: &RepositoryMockGetRightAnswersParams{ctx, partyID},
	}
	mmGetRightAnswers.expectations = append(mmGetRightAnswers.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetRightAnswers return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetRightAnswersExpectation) Then(iaa1 [][]int32, err error) *RepositoryMock {
	e.results = &RepositoryMockGetRightAnswersResults{iaa1, err}
	return e.mock
}

// GetRightAnswers implements Repository
func (mmGetRightAnswers *RepositoryMock) GetRightAnswers(ctx context.Context, partyID int64) (iaa1 [][]int32, err error) {
	mm_atomic.AddUint64(&mmGetRightAnswers.beforeGetRightAnswersCounter, 1)
	defer mm_atomic.AddUint64(&mmGetRightAnswers.afterGetRightAnswersCounter, 1)

	if mmGetRightAnswers.inspectFuncGetRightAnswers != nil {
		mmGetRightAnswers.inspectFuncGetRightAnswers(ctx, partyID)
	}

	mm_params := &RepositoryMockGetRightAnswersParams{ctx, partyID}

	// Record call args
	mmGetRightAnswers.GetRightAnswersMock.mutex.Lock()
	mmGetRightAnswers.GetRightAnswersMock.callArgs = append(mmGetRightAnswers.GetRightAnswersMock.callArgs, mm_params)
	mmGetRightAnswers.GetRightAnswersMock.mutex.Unlock()

	for _, e := range mmGetRightAnswers.GetRightAnswersMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.iaa1, e.results.err
		}
	}

	if mmGetRightAnswers.GetRightAnswersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetRightAnswers.GetRightAnswersMock.defaultExpectation.Counter, 1)
		mm_want := mmGetRightAnswers.GetRightAnswersMock.defaultExpectation.params
		mm_got := RepositoryMockGetRightAnswersParams{ctx, partyID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetRightAnswers.t.Errorf("RepositoryMock.GetRightAnswers got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetRightAnswers.GetRightAnswersMock.defaultExpectation.results
		if mm_results == nil {
			mmGetRightAnswers.t.Fatal("No results are set for the RepositoryMock.GetRightAnswers")
		}
		return (*mm_results).iaa1, (*mm_results).err
	}
	if mmGetRightAnswers.funcGetRightAnswers != nil {
		return mmGetRightAnswers.funcGetRightAnswers(ctx, partyID)
	}
	mmGetRightAnswers.t.Fatalf("Unexpected call to RepositoryMock.GetRightAnswers. %v %v", ctx, partyID)
	return
}

// GetRightAnswersAfterCounter returns a count of finished RepositoryMock.GetRightAnswers invocations
func (mmGetRightAnswers *RepositoryMock) GetRightAnswersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRightAnswers.afterGetRightAnswersCounter)
}

// GetRightAnswersBeforeCounter returns a count of RepositoryMock.GetRightAnswers invocations
func (mmGetRightAnswers *RepositoryMock) GetRightAnswersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRightAnswers.beforeGetRightAnswersCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetRightAnswers.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetRightAnswers *mRepositoryMockGetRightAnswers) Calls() []*RepositoryMockGetRightAnswersParams {
	mmGetRightAnswers.mutex.RLock()

	argCopy := make([]*RepositoryMockGetRightAnswersParams, len(mmGetRightAnswers.callArgs))
	copy(argCopy, mmGetRightAnswers.callArgs)

	mmGetRightAnswers.mutex.RUnlock()

	return argCopy
}

// MinimockGetRightAnswersDone returns true if the count of the GetRightAnswers invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetRightAnswersDone() bool {
	for _, e := range m.GetRightAnswersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetRightAnswersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetRightAnswersCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRightAnswers != nil && mm_atomic.LoadUint64(&m.afterGetRightAnswersCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetRightAnswersInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetRightAnswersInspect() {
	for _, e := range m.GetRightAnswersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetRightAnswers with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetRightAnswersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetRightAnswersCounter) < 1 {
		if m.GetRightAnswersMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.GetRightAnswers")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetRightAnswers with params: %#v", *m.GetRightAnswersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRightAnswers != nil && mm_atomic.LoadUint64(&m.afterGetRightAnswersCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.GetRightAnswers")
	}
}

type mRepositoryMockGetUserQuizTop struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetUserQuizTopExpectation
	expectations       []*RepositoryMockGetUserQuizTopExpectation

	callArgs []*RepositoryMockGetUserQuizTopParams
	mutex    sync.RWMutex
}

// RepositoryMockGetUserQuizTopExpectation specifies expectation struct of the Repository.GetUserQuizTop
type RepositoryMockGetUserQuizTopExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockGetUserQuizTopParams
	results *RepositoryMockGetUserQuizTopResults
	Counter uint64
}

// RepositoryMockGetUserQuizTopParams contains parameters of the Repository.GetUserQuizTop
type RepositoryMockGetUserQuizTopParams struct {
	ctx    context.Context
	quizID int64
	userID int64
}

// RepositoryMockGetUserQuizTopResults contains results of the Repository.GetUserQuizTop
type RepositoryMockGetUserQuizTopResults struct {
	s1  models.SingleTop
	err error
}

// Expect sets up expected params for Repository.GetUserQuizTop
func (mmGetUserQuizTop *mRepositoryMockGetUserQuizTop) Expect(ctx context.Context, quizID int64, userID int64) *mRepositoryMockGetUserQuizTop {
	if mmGetUserQuizTop.mock.funcGetUserQuizTop != nil {
		mmGetUserQuizTop.mock.t.Fatalf("RepositoryMock.GetUserQuizTop mock is already set by Set")
	}

	if mmGetUserQuizTop.defaultExpectation == nil {
		mmGetUserQuizTop.defaultExpectation = &RepositoryMockGetUserQuizTopExpectation{}
	}

	mmGetUserQuizTop.defaultExpectation.params = &RepositoryMockGetUserQuizTopParams{ctx, quizID, userID}
	for _, e := range mmGetUserQuizTop.expectations {
		if minimock.Equal(e.params, mmGetUserQuizTop.defaultExpectation.params) {
			mmGetUserQuizTop.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUserQuizTop.defaultExpectation.params)
		}
	}

	return mmGetUserQuizTop
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetUserQuizTop
func (mmGetUserQuizTop *mRepositoryMockGetUserQuizTop) Inspect(f func(ctx context.Context, quizID int64, userID int64)) *mRepositoryMockGetUserQuizTop {
	if mmGetUserQuizTop.mock.inspectFuncGetUserQuizTop != nil {
		mmGetUserQuizTop.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetUserQuizTop")
	}

	mmGetUserQuizTop.mock.inspectFuncGetUserQuizTop = f

	return mmGetUserQuizTop
}

// Return sets up results that will be returned by Repository.GetUserQuizTop
func (mmGetUserQuizTop *mRepositoryMockGetUserQuizTop) Return(s1 models.SingleTop, err error) *RepositoryMock {
	if mmGetUserQuizTop.mock.funcGetUserQuizTop != nil {
		mmGetUserQuizTop.mock.t.Fatalf("RepositoryMock.GetUserQuizTop mock is already set by Set")
	}

	if mmGetUserQuizTop.defaultExpectation == nil {
		mmGetUserQuizTop.defaultExpectation = &RepositoryMockGetUserQuizTopExpectation{mock: mmGetUserQuizTop.mock}
	}
	mmGetUserQuizTop.defaultExpectation.results = &RepositoryMockGetUserQuizTopResults{s1, err}
	return mmGetUserQuizTop.mock
}

//Set uses given function f to mock the Repository.GetUserQuizTop method
func (mmGetUserQuizTop *mRepositoryMockGetUserQuizTop) Set(f func(ctx context.Context, quizID int64, userID int64) (s1 models.SingleTop, err error)) *RepositoryMock {
	if mmGetUserQuizTop.defaultExpectation != nil {
		mmGetUserQuizTop.mock.t.Fatalf("Default expectation is already set for the Repository.GetUserQuizTop method")
	}

	if len(mmGetUserQuizTop.expectations) > 0 {
		mmGetUserQuizTop.mock.t.Fatalf("Some expectations are already set for the Repository.GetUserQuizTop method")
	}

	mmGetUserQuizTop.mock.funcGetUserQuizTop = f
	return mmGetUserQuizTop.mock
}

// When sets expectation for the Repository.GetUserQuizTop which will trigger the result defined by the following
// Then helper
func (mmGetUserQuizTop *mRepositoryMockGetUserQuizTop) When(ctx context.Context, quizID int64, userID int64) *RepositoryMockGetUserQuizTopExpectation {
	if mmGetUserQuizTop.mock.funcGetUserQuizTop != nil {
		mmGetUserQuizTop.mock.t.Fatalf("RepositoryMock.GetUserQuizTop mock is already set by Set")
	}

	expectation := &RepositoryMockGetUserQuizTopExpectation{
		mock:   mmGetUserQuizTop.mock,
		params: &RepositoryMockGetUserQuizTopParams{ctx, quizID, userID},
	}
	mmGetUserQuizTop.expectations = append(mmGetUserQuizTop.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetUserQuizTop return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetUserQuizTopExpectation) Then(s1 models.SingleTop, err error) *RepositoryMock {
	e.results = &RepositoryMockGetUserQuizTopResults{s1, err}
	return e.mock
}

// GetUserQuizTop implements Repository
func (mmGetUserQuizTop *RepositoryMock) GetUserQuizTop(ctx context.Context, quizID int64, userID int64) (s1 models.SingleTop, err error) {
	mm_atomic.AddUint64(&mmGetUserQuizTop.beforeGetUserQuizTopCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUserQuizTop.afterGetUserQuizTopCounter, 1)

	if mmGetUserQuizTop.inspectFuncGetUserQuizTop != nil {
		mmGetUserQuizTop.inspectFuncGetUserQuizTop(ctx, quizID, userID)
	}

	mm_params := &RepositoryMockGetUserQuizTopParams{ctx, quizID, userID}

	// Record call args
	mmGetUserQuizTop.GetUserQuizTopMock.mutex.Lock()
	mmGetUserQuizTop.GetUserQuizTopMock.callArgs = append(mmGetUserQuizTop.GetUserQuizTopMock.callArgs, mm_params)
	mmGetUserQuizTop.GetUserQuizTopMock.mutex.Unlock()

	for _, e := range mmGetUserQuizTop.GetUserQuizTopMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmGetUserQuizTop.GetUserQuizTopMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUserQuizTop.GetUserQuizTopMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUserQuizTop.GetUserQuizTopMock.defaultExpectation.params
		mm_got := RepositoryMockGetUserQuizTopParams{ctx, quizID, userID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUserQuizTop.t.Errorf("RepositoryMock.GetUserQuizTop got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUserQuizTop.GetUserQuizTopMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUserQuizTop.t.Fatal("No results are set for the RepositoryMock.GetUserQuizTop")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmGetUserQuizTop.funcGetUserQuizTop != nil {
		return mmGetUserQuizTop.funcGetUserQuizTop(ctx, quizID, userID)
	}
	mmGetUserQuizTop.t.Fatalf("Unexpected call to RepositoryMock.GetUserQuizTop. %v %v %v", ctx, quizID, userID)
	return
}

// GetUserQuizTopAfterCounter returns a count of finished RepositoryMock.GetUserQuizTop invocations
func (mmGetUserQuizTop *RepositoryMock) GetUserQuizTopAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserQuizTop.afterGetUserQuizTopCounter)
}

// GetUserQuizTopBeforeCounter returns a count of RepositoryMock.GetUserQuizTop invocations
func (mmGetUserQuizTop *RepositoryMock) GetUserQuizTopBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserQuizTop.beforeGetUserQuizTopCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetUserQuizTop.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUserQuizTop *mRepositoryMockGetUserQuizTop) Calls() []*RepositoryMockGetUserQuizTopParams {
	mmGetUserQuizTop.mutex.RLock()

	argCopy := make([]*RepositoryMockGetUserQuizTopParams, len(mmGetUserQuizTop.callArgs))
	copy(argCopy, mmGetUserQuizTop.callArgs)

	mmGetUserQuizTop.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserQuizTopDone returns true if the count of the GetUserQuizTop invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetUserQuizTopDone() bool {
	for _, e := range m.GetUserQuizTopMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserQuizTopMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetUserQuizTopCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUserQuizTop != nil && mm_atomic.LoadUint64(&m.afterGetUserQuizTopCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetUserQuizTopInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetUserQuizTopInspect() {
	for _, e := range m.GetUserQuizTopMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetUserQuizTop with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserQuizTopMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetUserQuizTopCounter) < 1 {
		if m.GetUserQuizTopMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.GetUserQuizTop")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetUserQuizTop with params: %#v", *m.GetUserQuizTopMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUserQuizTop != nil && mm_atomic.LoadUint64(&m.afterGetUserQuizTopCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.GetUserQuizTop")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RepositoryMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAddAllPartyQuestionInspect()

		m.MinimockAddPartyInspect()

		m.MinimockAddQuestionsIfNotInspect()

		m.MinimockAddUserInspect()

		m.MinimockCheckPartyCompletedInspect()

		m.MinimockCompletePartyInspect()

		m.MinimockGetQuizInspect()

		m.MinimockGetQuizListInspect()

		m.MinimockGetQuizTopInspect()

		m.MinimockGetRightAnswersInspect()

		m.MinimockGetUserQuizTopInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddAllPartyQuestionDone() &&
		m.MinimockAddPartyDone() &&
		m.MinimockAddQuestionsIfNotDone() &&
		m.MinimockAddUserDone() &&
		m.MinimockCheckPartyCompletedDone() &&
		m.MinimockCompletePartyDone() &&
		m.MinimockGetQuizDone() &&
		m.MinimockGetQuizListDone() &&
		m.MinimockGetQuizTopDone() &&
		m.MinimockGetRightAnswersDone() &&
		m.MinimockGetUserQuizTopDone()
}
